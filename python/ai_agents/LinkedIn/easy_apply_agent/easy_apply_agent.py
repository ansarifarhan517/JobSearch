import os
import sys

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../..')))
import json
import time
import re
import pandas as pd
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException


from managers.driver_manager import DriverManager
from managers.config_manager import ConfigManager

class LinkedInAutoApply:
    def __init__(self, username, password, filtered_csv="filtered_jobs.csv"):
        self.username = username
        self.password = password
        self.filtered_csv = filtered_csv
        self.applied_jobs = []

        # --- Chrome profiles ---
        self.user_data_dir = "~/Library/Application Support/Google/Chrome"
        self.profiles = ["Default"]  # fallback


        # Selenium driver and wait
        self.driver = None
        self.wait = None

        # Selenium / driver setup
        self.driver_manager = DriverManager(self.user_data_dir, self.profiles[0])
        self.driver, self.wait = self.driver_manager.get_driver()

        # Per-user Q&A file
        self.qa_file = f"answers_{username}.json"
        if os.path.exists(self.qa_file):
            with open(self.qa_file, "r") as f:
                self.qa_data = json.load(f)
        else:
            self.qa_data = {}

    # ---------------- Login ----------------
    def login(self):
        self.driver.get("https://www.linkedin.com/login")
        time.sleep(3)

        # Check if already logged in via cookies
        current_url = self.driver.current_url
        if "feed" in current_url or "jobs" in current_url:
            print("‚úÖ Logged in automatically via Chrome profile cookies.")
            return

        try:
            username_input = self.wait.until(EC.presence_of_element_located((By.ID, "username")))
            username_input.clear()
            username_input.send_keys(self.username)
            pwd_input = self.driver.find_element(By.ID, "password")
            pwd_input.clear()
            pwd_input.send_keys(self.password + Keys.RETURN)
            self.wait.until(lambda d: "feed" in d.current_url or "jobs" in d.current_url)
            print("‚úÖ Logged in successfully.")
        except TimeoutException:
            print("‚õî Login failed.")

    # ---------------- LLM placeholder ----------------
    def get_answer_from_llm(self, question, context=None):
        # TODO: Replace with OpenRouter API call
        return "Sample answer generated by LLM"


    def handle_easy_apply_form(self, job_id):
        try:
            # Wait for Easy Apply modal
            self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, ".jobs-easy-apply-modal")))

            while True:  # loop until Submit Application step
                modal = self.driver.find_element(By.CSS_SELECTOR, ".jobs-easy-apply-modal")

                # === STEP 1: Handle Radio Groups ===
                radio_groups = modal.find_elements(By.CSS_SELECTOR, "fieldset")
                for group in radio_groups:
                    try:
                        legend_el = group.find_element(By.TAG_NAME, "legend")
                        question = self.normalize_question(legend_el.text.strip())

                    except:
                        question = "Unknown Radio Question"

                    options = group.find_elements(By.CSS_SELECTOR, "input[type='radio']")
                    current_value = next((o.get_attribute("value") for o in options if o.is_selected()), "")
                    answer = self.qa_data.get(question)

                    if answer: # Case 1
                        # prefer Qa data answer
                        if current_value.lower() != answer.lower():
                              for opt in options:
                                if (opt.get_attribute("value") or "").lower() == answer.lower():
                                    self.driver.execute_script("arguments[0].click();", opt)
                                    print(f"üîé Radio Question: {question} ‚Üí Updated to {answer}")
                                    break
                    else:
                       if current_value:  # Case 2
                        self.qa_data[question] = current_value
                        self.save_qa_data()

                        print(f"üì• Learned radio answer for {question}: {current_value}")
                       else:  # Case 3
                        user_answer = input(f"‚ùì Radio Question: {question} ‚Üí Please provide an answer: ")
                        self.qa_data[question] = user_answer
                        self.save_qa_data()
                        print(f"üì• Learned radio answer for {question}: {user_answer}")

                        for opt in options:
                            if (opt.get_attribute("value") or "").lower() == user_answer.lower():
                                self.driver.execute_script("arguments[0].click();", opt)
                                break
                
                # === STEP 2: Handle Text Inputs ===
                text_inputs = modal.find_elements(By.CSS_SELECTOR, "input[type='text'], textarea")
                for t in text_inputs:
                    try:
                        label_el = t.find_element(By.XPATH, "./preceding::label[1]")
                        question = self.normalize_question(label_el.text.strip())
                    except:
                        question = t.get_attribute("placeholder") or "Unknown Text Question"

                    # Detect expected input type
                    expected_type = t.get_attribute("type") or "text"
                    input_mode = t.get_attribute("inputmode") or ""

                    if input_mode == "numeric" or "number" in expected_type:
                        expected_type = "number"
                    elif input_mode == "decimal":
                        expected_type = "float"

                    current_value = t.get_attribute("value").strip()
                    answer = self.qa_data.get(question)

                    if answer:  # Case 1: already in qa_data
                        if current_value != answer:
                            t.clear()
                            t.send_keys(answer)
                            print(f"üîé Text Question: {question} ‚Üí Updated to {answer}")
                    else:
                        if current_value:  # Case 2: prefilled
                            self.qa_data[question] = current_value
                            self.save_qa_data()
                            print(f"üì• Learned text answer for {question}: {current_value}")
                        else:  # Case 3: ask user
                            while True:
                                user_answer = input(
                                    f"\n‚ùì Text Question (expects {expected_type}):\n   {question}\n   ‚Üí Please provide an answer: "
                                ).strip()
                                if expected_type == "number":
                                    if user_answer.isdigit():
                                        break
                                    print("‚ö†Ô∏è Please enter a valid integer.")
                                elif expected_type == "float":
                                    try:
                                        float(user_answer)
                                        break
                                    except ValueError:
                                        print("‚ö†Ô∏è Please enter a valid number (float allowed).")
                                else:
                                    if user_answer:
                                        break
                                    print("‚ö†Ô∏è Answer cannot be empty.")

                            self.qa_data[question] = user_answer
                            self.save_qa_data()
                            print(f"üì• Learned text answer for {question}: {user_answer}")
                            t.clear()
                            t.send_keys(user_answer)

                # === STEP 3: Handle Dropdowns ===
                dropdowns = modal.find_elements(By.CSS_SELECTOR, "select")
                for d in dropdowns:
                    try:
                        label_el = d.find_element(By.XPATH, "./preceding::label[1]")
                        span = label_el.find_elements(By.XPATH, ".//span[@aria-hidden='true']")
                        if span:
                            question_text = span[0].text.strip()
                        else:
                            question_text = label_el.text.strip()
                        question = self.normalize_question(question_text)
                    except:
                        question = "Unknown Dropdown Question"

                    current_value = d.get_attribute("value").strip()
                    answer = self.qa_data.get(question)

                    options = d.find_elements(By.TAG_NAME, "option")
                    valid_opts = [o for o in options if o.get_attribute("value")]

                    if answer and answer.lower() != 'select an option':  # Case 1: use saved
                        if current_value.lower() != answer.lower():
                            for o in valid_opts:
                                if o.text.strip().lower() == answer.lower() or o.get_attribute("value").lower() == answer.lower():
                                    o.click()
                                    print(f"üîé Dropdown Question: {question} ‚Üí Updated to {answer}")
                                    break
                    else:
                        if current_value and current_value.lower() != "select an option":  # Case 2: prefilled
                            self.qa_data[question] = current_value
                            self.save_qa_data()
                            print(f"üì• Learned dropdown answer for {question}: {current_value}")
                        else:  # Case 3: ask user
                            print(f"\n‚ùì Dropdown Question:\n   {question}")
                            print("   Please choose one of the following options:")
                            for idx, o in enumerate(valid_opts, start=1):
                                print(f"     {idx}. {o.text.strip()}")

                            while True:
                                choice = input("   ‚Üí Enter the number of your choice: ").strip()
                                if choice.isdigit() and 1 <= int(choice) <= len(valid_opts):
                                    selected = valid_opts[int(choice) - 1]
                                    user_answer = selected.text.strip()
                                    selected.click()
                                    break
                                else:
                                    print("‚ö†Ô∏è Invalid choice. Please enter a valid number.")

                            self.qa_data[question] = user_answer
                            self.save_qa_data()
                            print(f"üì• Learned dropdown answer for {question}: {user_answer}")

                # === STEP 4: Try to go to next page or submit ===
                try:
                    next_btn = modal.find_element(By.CSS_SELECTOR, "button[aria-label='Continue to next step']")
                    if next_btn.is_enabled():
                        self.driver.execute_script("arguments[0].click();", next_btn)
                        # self.wait.until(EC.staleness_of(next_btn))  # wait for step change
                        continue
                except:
                    pass

                try:
                    review_btn = modal.find_element(By.CSS_SELECTOR, "button[aria-label='Review your application']")
                    if review_btn.is_enabled():
                        self.driver.execute_script("arguments[0].click();", review_btn)
                        self.wait.until(EC.staleness_of(review_btn))
                        continue
                except:
                    pass

                try:
                    submit_btn = modal.find_element(By.CSS_SELECTOR, "button[aria-label='Submit application']")
                    if submit_btn.is_enabled():
                        self.driver.execute_script("arguments[0].click();", submit_btn)
                        print("‚úÖ Application submitted!")
                        try:
                            job_title = self.driver.find_element(By.CSS_SELECTOR, "h1.top-card-layout__title").text.strip()
                        except:
                            job_title = "Unknown"

                        try:
                            company_name = self.driver.find_element(By.CSS_SELECTOR, "a.topcard__org-name-link").text.strip()
                        except:
                            company_name = "Unknown"

                        try:
                            location = self.driver.find_element(By.CSS_SELECTOR, "span.topcard__flavor--bullet").text.strip()
                        except:
                            location = "Unknown"

                        try:
                            description = self.driver.find_element(By.CSS_SELECTOR, "div.show-more-less-html__markup").text.strip()
                        except:
                            description = "N/A"

                        self.applied_jobs.append({
                            "Job ID": job_id,
                            "Job Title": job_title,
                            "Company": company_name,
                            "Location": location,
                            "Description": description,
                            "URL": self.driver.current_url,
                            "Applied At": time.strftime("%Y-%m-%d %H:%M:%S")
                        })
                        return
                except:
                    pass

                # If none of the buttons found, break
                print("‚ö†Ô∏è Could not find next/review/submit button. Stopping.")
                break

        except Exception as e:
            print(f"‚õî Error in handle_easy_apply_form: {e}")

    def apply_jobs(self):
        df = pd.read_csv(self.filtered_csv)
        jobs_to_apply = df[df["Final Opinion"] > 5]

        for idx, row in jobs_to_apply.iterrows():
            job_id = row.get("LinkedIn Job ID") or row.get("Job URL")  # fallback to URL if ID missing
            job_url = row.get("Job URL")
            if not job_url:
                print(f"‚ö†Ô∏è Job URL missing for {job_id}, skipping.")
                continue

            # Open job page
            self.driver.get(job_url)
            time.sleep(10)
            print(f"‚û°Ô∏è Processing job {job_id}")

            # Check Easy Apply
            try:
                #wait till button is present
                easy_apply_button = self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "button.jobs-apply-button")))
                if "Easy Apply" in easy_apply_button.text:
                    easy_apply_button.click()
                    time.sleep(2)
                    self.handle_easy_apply_form(job_id)
                else:
                    print(f"‚ÑπÔ∏è Easy Apply not available for {job_id}")
            except (NoSuchElementException, TimeoutException):
                e = sys.exc_info()[1]
                if isinstance(e, NoSuchElementException):
                    print(f"‚ÑπÔ∏è Easy Apply button not found for {job_id}")
                elif isinstance(e, TimeoutException):
                    print(f"‚ÑπÔ∏è Easy Apply button timed out for {job_id}")
                    jobs_withoutEasyApply = "../../../jobs_without_easyapply.csv"
                    if os.path.exists(jobs_withoutEasyApply):
                        df_no_easy = pd.read_csv(jobs_withoutEasyApply)
                        df_no_easy.add_row(row)
                        df_no_easy.to_csv(jobs_withoutEasyApply, index=False)
                        print(f"üìä Logged job without Easy Apply to {jobs_withoutEasyApply}")
                    else:
                        df_no_easy = pd.DataFrame([row])
                        df_no_easy.to_csv(jobs_withoutEasyApply, index=False)
                        print(f"üìä Logged job without Easy Apply to {jobs_withoutEasyApply}")

        # Save QA data
        with open(self.qa_file, "w") as f:
            json.dump(self.qa_data, f, indent=2)
        print("‚úÖ Saved question-answer data.")

    # ---------------- Run ----------------
    def run(self):
        self.login()
        self.apply_jobs()
        if self.applied_jobs:
            applied_csv = f"applied_jobs_{self.username}.csv"
            df = pd.DataFrame(self.applied_jobs)
            df.to_csv(applied_csv, index=False)
            print(f"üìä Saved {len(self.applied_jobs)} applied jobs to {applied_csv}")
        else:
            print("‚ÑπÔ∏è No jobs applied today.")
        self.driver.quit()


    def normalize_question(self, text: str) -> str:
        """Clean LinkedIn question text consistently."""
        if not text:
            return "Unknown Question"

        q = str(text)  # make sure it's a string
        q = q.strip()

        # Remove newlines
        q = re.sub(r"\s+", " ", q)

        # Remove trailing 'Required'
        q = re.sub(r"\bRequired\b", "", q, flags=re.IGNORECASE)
        
        # 3. Collapse repeated phrases
        # If the text consists of the same phrase repeated (case-insensitive)
        words = q.split()
        half = len(words) // 2
        if len(words) % 2 == 0 and words[:half] == words[half:]:
            q = " ".join(words[:half])

        # 4. Optional: deduplicate repeated sentences ending with ?
        if "?" in q:
            parts = q.split("?")
            if len(parts) > 2:
                q = parts[0].strip() + "?"

        return q

    def save_qa_data(self):
        """Persist learned Q/A data to file."""
        try:
            with open(self.qa_file, "w") as f:
                json.dump(self.qa_data, f, indent=2)
            print("‚úÖ Saved question-answer data.")
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to save QA data: {e}")

# ---------------- Usage ----------------
# if __name__ == "__main__":
    # USERNAME = os.getenv("LINKEDIN_EMAIL")
    # PASSWORD = os.getenv("LINKEDIN_PASSWORD")
    # auto_apply = LinkedInAutoApply(USERNAME, PASSWORD, filtered_csv="filtered_jobs.csv")
    # auto_apply.run()
